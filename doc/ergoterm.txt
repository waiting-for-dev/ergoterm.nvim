*ergoterm.txt*  Flexible terminal management for Neovim

==============================================================================
CONTENTS                                                   *ergoterm-contents*

    1. Introduction ........................... |ergoterm-introduction|
    2. Setup .................................. |ergoterm-setup|
    3. Use Cases .............................. |ergoterm-use-cases|
        3.1 On-Demand Terminal Access ........ |ergoterm-on-demand|
        3.2 Interactive AI Assistants ........ |ergoterm-ai-assistants|
        3.3 Test Runner ...................... |ergoterm-test-runner|
        3.4 Task Runner ...................... |ergoterm-task-runner|
        3.5 Development Environment .......... |ergoterm-dev-environment|
        3.6 Project Initialization ........... |ergoterm-project-init|
    4. Configuration .......................... |ergoterm-configuration|
        4.1 Terminal Defaults ................ |ergoterm-terminal-defaults|
        4.2 Picker Configuration ............. |ergoterm-picker-config|
        4.3 Text Decorators .................. |ergoterm-text-decorators|
    5. Commands ............................... |ergoterm-commands|
    6. API Reference .......................... |ergoterm-api|
        6.1 Collection Methods ............... |ergoterm-collection|
        6.2 Instance Methods ................. |ergoterm-instance|
    7. About .................................. |ergoterm-about|

==============================================================================
1. INTRODUCTION                                        *ergoterm-introduction*

A flexible terminal management plugin for Neovim that puts you in control of
your workflow.

PHILOSOPHY ~

Most Neovim terminal integration follows a tool-specific approach: specialized
plugins for AI chats, testing, task runners and other CLI tools (e.g.,
lazygit), each with their own terminal implementation and UI decisions. This
creates friction when you want consistent behavior across tools or when no
plugin exists for your preferred CLI application.

ergoterm inverts this with a terminal-first approach: a single, powerful
terminal abstraction that adapts to any CLI tool. Instead of conforming to
various plugin constraints, you configure terminals with exactly the behavior
you need.

The terminal becomes your universal integration layer. You own the workflow;
the terminals adapt to it.

==============================================================================
2. SETUP                                                      *ergoterm-setup*

Using lazy.nvim: >lua

    {
      "waiting-for-dev/ergoterm.nvim",
      config = function()
        require("ergoterm").setup()
      end
    }
<

Using packer.nvim: >lua

    use {
      "waiting-for-dev/ergoterm.nvim",
      config = function()
        require("ergoterm").setup()
      end
    }
<

==============================================================================
3. USE CASES                                              *ergoterm-use-cases*

------------------------------------------------------------------------------
3.1 ON-DEMAND TERMINAL ACCESS                             *ergoterm-on-demand*

For ad-hoc terminal operations through Vim commands.

See full guide: https://github.com/waiting-for-dev/ergoterm.nvim/blob/main/docs/on-demand-usage.md

TERMINAL SELECTION PATTERN ~

Most commands support three ways to select terminals:

1. Bang (`!`) - Use the last focused terminal >vim
    :TermSelect!
    :TermSend!
<

2. Target by name - Specify terminal by name >vim
    :TermSelect target=myterminal
    :TermSend target=tests
<

3. Picker - Open selection UI (default) >vim
    :TermSelect
    :TermSend
<

BASIC KEYBINDINGS ~
>lua
    local map = vim.keymap.set
    local opts = { noremap = true, silent = true }

    -- Create terminals with different layouts
    map("n", "<leader>cs", ":TermNew layout=below<CR>", opts)
    map("n", "<leader>cv", ":TermNew layout=right<CR>", opts)
    map("n", "<leader>cf", ":TermNew layout=float<CR>", opts)

    -- Open terminal picker
    map("n", "<leader>cl", ":TermSelect<CR>", opts)

    -- Send text to last focused terminal
    map("n", "<leader>cs", ":TermSend! new_line=false<CR>", opts)
    map("x", "<leader>cs", ":TermSend! new_line=false<CR>", opts)
<

------------------------------------------------------------------------------
3.2 INTERACTIVE AI ASSISTANTS                        *ergoterm-ai-assistants*

Integrate AI chat tools (like Claude CLI, Cursor, Aider) into your workflow.

See full guide: https://github.com/waiting-for-dev/ergoterm.nvim/blob/main/docs/interactive-ai-assistants.md

SIMPLE SETUP ~
>lua
    local ergoterm = require("ergoterm")

    local claude = ergoterm:new({
      cmd = "claude",
      name = "claude",
      layout = "right",
      auto_list = false,
      bang_target = false,
      sticky = true,
      watch_files = true
    })
<

MULTIPLE AI ASSISTANTS ~
>lua
    local ai_chats = ergoterm.with_defaults({
      layout = "right",
      auto_list = false,
      bang_target = false,
      sticky = true,
      watch_files = true,
      tags = { "ai_chat" }
    })

    local claude_sonnet = ai_chats:new({
      cmd = "claude --model sonnet",
      name = "claude (sonnet)",
      meta = {
        add_file = function(file) return "@" .. file end
      }
    })

    local aider = ai_chats:new({
      cmd = "aider",
      name = "aider",
      meta = {
        add_file = function(file) return "/add " .. file end
      }
    })
<

SMART SELECTION ~
>lua
    local chats = ergoterm.filter_by_tag("ai_chat")

    vim.keymap.set("n", "<leader>as", function()
      ergoterm.select_started({
        terminals = chats,
        prompt = "Send to chat",
        callbacks = function(term)
          return term:send("single_line")
        end,
        default = claude_sonnet
      })
    end)
<

------------------------------------------------------------------------------
3.3 TEST RUNNER                                        *ergoterm-test-runner*

Integrate test runners into your Neovim workflow.

See full guide: https://github.com/waiting-for-dev/ergoterm.nvim/blob/main/docs/test-runner.md

EXAMPLE SETUP ~
>lua
    local ergoterm = require("ergoterm")

    local rspec = ergoterm:new({
      auto_list = false,
      bang_target = false,
      sticky = true,
      layout = "below",
      size = { below = "20%" },
      auto_scroll = true
    })
<

BASIC KEYBINDINGS ~
>lua
    -- Test single test at cursor
    vim.keymap.set("n", "<leader>tt", function()
      rspec:send({
        'bundle exec rspec ' .. vim.fn.expand("%") .. ':' .. vim.fn.line(".")
      }, { action = "open" })
    end, { desc = "Test single test" })

    -- Test current file
    vim.keymap.set("n", "<leader>tf", function()
      rspec:send({ 'bundle exec rspec ' .. vim.fn.expand("%") },
        { action = "open" })
    end, { desc = "Test current file" })

    -- Re-run last test
    vim.keymap.set("n", "<leader>tl", function()
      rspec:send("last", { action = "open" })
    end, { desc = "Re-run last test" })
<

------------------------------------------------------------------------------
3.4 TASK RUNNER                                        *ergoterm-task-runner*

Quick access to common project tasks using project-specific configuration.

See full guide: https://github.com/waiting-for-dev/ergoterm.nvim/blob/main/docs/task-runner.md

PROJECT-SPECIFIC SETUP ~

Create a `.nvim.lua` file in your project root: >lua

    local ergoterm = require("ergoterm")

    local tasks = ergoterm.with_defaults({
      layout = "below",
      size = { below = "30%" },
      tags = { "task" },
      auto_list = false,
      bang_target = false,
      sticky = true,
      auto_scroll = true,
      default_action = function(term) term:open() end
    })

    -- Define common tasks
    local db_migrate = tasks:new({
      name = "db:migrate",
      cmd = "rails db:migrate"
    })

    local db_seed = tasks:new({
      name = "db:seed",
      cmd = "rails db:seed"
    })

    -- Task selection keybinding
    local task_list = ergoterm.filter_by_tag("task")

    vim.keymap.set("n", ",t", function()
      ergoterm.select({
        terminals = task_list,
        prompt = "Run Task"
      })
    end, { noremap = true, silent = true, desc = "Run Task" })
<

------------------------------------------------------------------------------
3.5 DEVELOPMENT ENVIRONMENT                        *ergoterm-dev-environment*

Create comprehensive development environments with project-specific terminals.

See full guide: https://github.com/waiting-for-dev/ergoterm.nvim/blob/main/docs/development-environment.md

PROJECT-SPECIFIC SETUP ~

Create a `.nvim.lua` file in your project root: >lua

    local ergoterm = require("ergoterm")

    -- Development server (Phoenix)
    local dev_server = ergoterm:new({
      name = "dev",
      cmd = "mix phx.server",
      layout = "right",
      size = { right = "40%" },
      sticky = true
    })

    -- Staging console (connected to Fly.io)
    local staging_console = ergoterm:new({
      name = "staging",
      cmd = "fly ssh console --app myapp-staging " ..
           "--command '/app/bin/myapp remote'",
      layout = "right",
      size = { right = "40%" },
      sticky = true
    })

    -- Local database (psql)
    local local_db = ergoterm:new({
      name = "db-local",
      cmd = "psql -U postgres -d myapp_dev",
      layout = "below",
      size = { below = "30%" },
      sticky = true
    })
<

Use `:TermSelect` to access all defined terminals.

------------------------------------------------------------------------------
3.6 PROJECT INITIALIZATION                              *ergoterm-project-init*

Automatically run initialization tasks when opening a project.

See full guide: https://github.com/waiting-for-dev/ergoterm.nvim/blob/main/docs/project-initialization.md

BACKGROUND INITIALIZATION ~

Create a `.nvim.lua` file in your project root: >lua

    local ergoterm = require("ergoterm")

    -- Start Docker services
    local docker_init = ergoterm:new({
      name = "docker-init",
      cmd = "docker-compose up -d",
      auto_list = false,
      show_on_failure = true,
      sticky = true,
      on_job_exit = function(term, job, exit_code)
        if exit_code == 0 then
          vim.notify("Docker services started", vim.log.levels.INFO)
        end
      end
    })

    -- Fetch remote changes
    local git_fetch = ergoterm:new({
      name = "git-fetch",
      cmd = "git fetch --all --prune",
      auto_list = false,
      show_on_failure = true,
      sticky = true,
      on_job_exit = function(term, job, exit_code)
        if exit_code == 0 then
          vim.notify("Git fetch completed", vim.log.levels.INFO)
        end
      end
    })

    -- Start both terminals in the background
    docker_init:start()
    git_fetch:start()
<

With `show_on_failure = true`, terminals run silently in the background but
automatically surface if they fail.

==============================================================================
4. CONFIGURATION                                      *ergoterm-configuration*

------------------------------------------------------------------------------
4.1 TERMINAL DEFAULTS                             *ergoterm-terminal-defaults*

All options can be set globally in `setup()` under `terminal_defaults`, or
per-terminal when creating instances.
>lua
    require("ergoterm").setup({
      terminal_defaults = {
        layout = "right",
        cleanup_on_success = false,
        auto_scroll = true
      }
    })
<

OPTIONS ~

auto_list                                               *ergoterm-auto_list*
    Type: `boolean`
    Default: `true`
    Show terminal in default picker selection list (e.g., `:TermSelect`)

auto_scroll                                           *ergoterm-auto_scroll*
    Type: `boolean`
    Default: `false`
    Automatically scroll to bottom on new output

bang_target                                           *ergoterm-bang_target*
    Type: `boolean`
    Default: `true`
    Include terminal as target for bang (`!`) commands

clear_env                                               *ergoterm-clear_env*
    Type: `boolean`
    Default: `false`
    Clear environment variables before starting

cleanup_on_failure                             *ergoterm-cleanup_on_failure*
    Type: `boolean`
    Default: `false`
    Cleanup terminal when process exits with non-zero code

cleanup_on_success                             *ergoterm-cleanup_on_success*
    Type: `boolean`
    Default: `true`
    Cleanup terminal when process exits with code 0

default_action                                     *ergoterm-default_action*
    Type: `function`
    Default: `function(term) term:focus() end`
    Action performed when selecting terminal with default picker action

float_opts                                             *ergoterm-float_opts*
    Type: `table`
    Floating window configuration options (see |nvim_open_win()|)
    Subkeys:
    - border: `string` (default: "single")
    - col: `number` (default: auto-centered)
    - height: `number` (default: auto-calculated)
    - relative: `string` (default: "editor")
    - row: `number` (default: auto-centered)
    - title: `string` (default: terminal name)
    - title_pos: `string` (default: "left")
    - width: `number` (default: auto-calculated)
    - zindex: `number` (default: +1)

float_winblend                                     *ergoterm-float_winblend*
    Type: `number`
    Default: `10`
    Transparency level for floating windows (0-100)

layout                                                     *ergoterm-layout*
    Type: `string`
    Default: `"below"`
    Window layout: "below", "above", "left", "right", "float", "tab",
    "window"

meta                                                         *ergoterm-meta*
    Type: `table`
    Default: `{}`
    Custom user metadata for storing arbitrary data. Useful for terminal
    polymorphism.

on_close                                                 *ergoterm-on_close*
    Type: `function`
    Default: No-op
    Callback when terminal window closes: `function(term)`

on_focus                                                 *ergoterm-on_focus*
    Type: `function`
    Default: No-op
    Callback when terminal gains focus: `function(term)`

on_job_exit                                           *ergoterm-on_job_exit*
    Type: `function`
    Default: No-op
    Callback when job exits: `function(term, job, exit_code, event)`

on_job_stderr                                       *ergoterm-on_job_stderr*
    Type: `function`
    Default: No-op
    Callback on stderr: `function(term, channel_id, data, name)`

on_job_stdout                                       *ergoterm-on_job_stdout*
    Type: `function`
    Default: No-op
    Callback on stdout: `function(term, channel_id, data, name)`

on_open                                                   *ergoterm-on_open*
    Type: `function`
    Default: No-op
    Callback when terminal window opens: `function(term)`

on_start                                                 *ergoterm-on_start*
    Type: `function`
    Default: No-op
    Callback when terminal job starts: `function(term)`

on_stop                                                   *ergoterm-on_stop*
    Type: `function`
    Default: No-op
    Callback when terminal job stops: `function(term)`

on_unfocus                                             *ergoterm-on_unfocus*
    Type: `function`
    Default: No-op
    Callback when terminal loses focus: `function(term)`

persist_mode                                         *ergoterm-persist_mode*
    Type: `boolean`
    Default: `false`
    Remember insert/normal mode between focus sessions

persist_size                                         *ergoterm-persist_size*
    Type: `boolean`
    Default: `true`
    Remember window size when resizing splits

scrollback                                             *ergoterm-scrollback*
    Type: `number`
    Default: `vim.o.scrollback`
    Terminal scrollback buffer size

shell                                                       *ergoterm-shell*
    Type: `string`
    Default: `vim.o.shell`
    Default shell command to run if no `cmd` is given

show_on_failure                                   *ergoterm-show_on_failure*
    Type: `boolean`
    Default: `false`
    Show terminal window when process fails (incompatible with
    `cleanup_on_failure`)

show_on_success                                   *ergoterm-show_on_success*
    Type: `boolean`
    Default: `false`
    Show terminal window when process succeeds (incompatible with
    `cleanup_on_success`)

size                                                         *ergoterm-size*
    Type: `table`
    Size for split layouts (number of rows/columns or percentage string)
    Subkeys:
    - above: `string|number` (default: "50%")
    - below: `string|number` (default: "50%")
    - left: `string|number` (default: "50%")
    - right: `string|number` (default: "50%")

start_in_insert                                   *ergoterm-start_in_insert*
    Type: `boolean`
    Default: `true`
    Start in insert mode when focusing terminal

sticky                                                     *ergoterm-sticky*
    Type: `boolean`
    Default: `false`
    Keep terminal active even after cleanup so it can be restarted

tags                                                         *ergoterm-tags*
    Type: `string[]`
    Default: `{}`
    Tags for organizing and filtering terminals

watch_files                                           *ergoterm-watch_files*
    Type: `boolean`
    Default: `false`
    Refresh buffer when stdout is received

------------------------------------------------------------------------------
4.2 PICKER CONFIGURATION                           *ergoterm-picker-config*

Configure terminal selection picker behavior.
>lua
    require("ergoterm").setup({
      picker = {
        picker = "telescope",
        extra_select_actions = {
          ["<C-d>"] = {
            fn = function(term) term:cleanup() end,
            desc = "Delete terminal"
          }
        }
      }
    })
<

extra_select_actions                         *ergoterm-extra_select_actions*
    Type: `table`
    Default: `{}`
    Additional custom keybindings merged with defaults

picker                                                     *ergoterm-picker*
    Type: `string|table|nil`
    Default: `nil`
    Picker implementation: `nil` (auto-detect), "telescope", "fzf-lua",
    "vim-ui-select", or custom picker table

select_actions                                     *ergoterm-select_actions*
    Type: `table`
    Default keybindings: `default` (runs `default_action`), `<C-s>` (open
    below), `<C-v>` (open right), `<C-t>` (open in tab), `<C-f>` (open
    float). Each action is a table with `fn` (callback function) and `desc`
    (description)

------------------------------------------------------------------------------
4.3 TEXT DECORATORS                               *ergoterm-text-decorators*

Text decorators transform text before sending to terminals.
>lua
    require("ergoterm").setup({
      text_decorators = {
        extra = {
          timestamp = function(text)
            local timestamp = os.date("%H:%M:%S")
            local result = {}
            for _, line in ipairs(text) do
              table.insert(result, string.format("[%s] %s", timestamp, line))
            end
            return result
          end
        }
      }
    })
<

default                                      *ergoterm-text_decorators-default*
    Type: `table`
    Built-in decorators: `identity` (no transformation), `markdown_code`
    (wraps in markdown code block)

extra                                          *ergoterm-text_decorators-extra*
    Type: `table`
    Default: `{}`
    Custom text decorators. Each decorator is a function that takes
    `string[]` and returns `string[]`

Use with `:TermSend decorator=name` or `term:send(input, {decorator = "name"})`.

==============================================================================
5. COMMANDS                                              *ergoterm-commands*

:TermNew                                                        *:TermNew*
    Create and focus a new terminal with optional configuration. >vim
        :TermNew [option=value ...]
<
    All options from |ergoterm-terminal-defaults| are supported except
    callbacks (`on_*` functions). Additionally:

    - cmd: Command to run (default: shell)
    - dir: Working directory (default: current directory). Special value:
      `git_dir` expands to git root
    - name: Terminal name (default: command name)

    Syntax for complex types:
    - Table settings: Use dot notation: `size.right="30%"`
    - List settings: Use comma-separated values: `tags=git,dev`

    Examples: >vim
        :TermNew
        :TermNew cmd=lazygit layout=float name=git
        :TermNew cmd=claude watch_files=true layout=right
        :TermNew cmd="rspec --watch" size.below="30%" name=tests
<

:TermSelect                                                  *:TermSelect*
    Open terminal picker or focus a specific terminal. >vim
        :TermSelect[!] [target=name]
<
    Examples: >vim
        :TermSelect
        :TermSelect!
        :TermSelect target=tests
<

:TermUpdate                                                  *:TermUpdate*
    Update terminal settings after creation. >vim
        :TermUpdate[!] option=value [option=value ...]
<
    All options from `:TermNew` can be updated except:
    - cmd
    - dir
    - scrollback
    - env

    Examples: >vim
        :TermUpdate! layout=float
        :TermUpdate target=server cleanup_on_success=false
<

:TermSend                                                      *:TermSend*
    Send text from buffer to terminal. >vim
        :TermSend[!] [option=value ...]
        :[range]TermSend[!] [option=value ...]
<
    Without a range, sends the current line. With a range (visual selection),
    sends selected text.

    Options:
    - action: Terminal action ("focus", "open", "start")
    - clear: Clear terminal before sending (boolean)
    - decorator: Text decorator to apply (string)
    - new_line: Append newline to execute command (boolean)
    - text: Explicit text to send (string)
    - trim: Trim leading/trailing whitespace (boolean)

    Examples: >vim
        :TermSend!
        :'<,'>TermSend!
        :TermSend! new_line=false
        :TermSend! action=open
        :TermSend text="npm test" target=tests
<

:TermInspect                                                *:TermInspect*
    Display terminal internal state for debugging. >vim
        :TermInspect[!] [target=name]
<

:TermToggleUniversalSelection                *:TermToggleUniversalSelection*
    Toggle universal selection mode, which makes all terminals visible from
    `:TermSelect` picker and a target for bang commands. >vim
        :TermToggleUniversalSelection
<

==============================================================================
6. API REFERENCE                                                *ergoterm-api*

The ergoterm API is split into two main components:

- Collection methods: Functions to manage and query all terminals
- Instance methods: Methods to control individual terminal instances

Example: >lua
    local ergoterm = require("ergoterm")

    -- Collection method: create a new terminal
    local term = ergoterm:new({ cmd = "htop", layout = "float" })

    -- Instance methods: control the terminal
    term:start()
    term:focus()
    term:send({ "q" })
<

------------------------------------------------------------------------------
6.1 COLLECTION METHODS                                  *ergoterm-collection*

Collection methods are accessed through the main ergoterm module.

ergoterm:new({args})                                        *ergoterm:new()*
    Creates a new terminal instance with the specified configuration.

    Parameters: ~
        {args}  (table, optional) Terminal configuration. See
                |ergoterm-terminal-defaults| for available options.
                Additional fields:
                - cmd: Command to run (default: shell)
                - dir: Working directory. Special: "git_dir" = git root
                - env: Environment variables (table)
                - name: Terminal name (made unique automatically if duplicate)
                - meta: Custom metadata (table)
                - tags: Tags for organizing (string[])

    Returns: ~
        Terminal instance

    Example: >lua
        local dev_server = ergoterm:new({
          name = "server",
          cmd = "npm run dev",
          layout = "right",
          tags = { "dev", "server" }
        })
<

ergoterm.with_defaults({custom_defaults})        *ergoterm.with_defaults()*
    Creates a factory for creating terminals with shared default settings.

    Parameters: ~
        {custom_defaults}  (table) Default configuration for all terminals
                          created by this factory

    Returns: ~
        Factory object with a `new(args)` method

    Example: >lua
        local tasks = ergoterm.with_defaults({
          layout = "below",
          size = { below = "30%" },
          sticky = true
        })

        local migrate = tasks:new({
          name = "migrate",
          cmd = "rails db:migrate"
        })
<

ergoterm.find({predicate})                               *ergoterm.find()*
    Finds the first terminal matching the given condition.

    Parameters: ~
        {predicate}  (function) Function that returns `true` for matching
                     terminals: `function(term)`

    Returns: ~
        Terminal or `nil`

    Example: >lua
        local server = ergoterm.find(function(term)
          return term.name == "server"
        end)
<

ergoterm.filter({predicate})                           *ergoterm.filter()*
    Returns all terminals matching the given condition.

    Parameters: ~
        {predicate}  (function) Function that returns `true` for matching
                     terminals: `function(term)`

    Returns: ~
        Array of Terminal instances

    Example: >lua
        local running = ergoterm.filter(function(term)
          return term:is_started()
        end)
<

ergoterm.get_all()                                     *ergoterm.get_all()*
    Returns all terminals in the current session.

    Returns: ~
        Array of Terminal instances

ergoterm.get({id})                                         *ergoterm.get()*
    Gets a terminal by its unique ID.

    Parameters: ~
        {id}  (number) Terminal ID

    Returns: ~
        Terminal or `nil`

ergoterm.get_by_name({name})                       *ergoterm.get_by_name()*
    Finds the terminal with the specified name.

    Parameters: ~
        {name}  (string) Terminal name

    Returns: ~
        Terminal or `nil`

    Example: >lua
        local server = ergoterm.get_by_name("server")
        if server then
          server:focus()
        end
<

ergoterm.filter_by_tag({tag})                     *ergoterm.filter_by_tag()*
    Returns all terminals that have the specified tag.

    Parameters: ~
        {tag}  (string) Tag to search for

    Returns: ~
        Array of Terminal instances

    Example: >lua
        local dev_terminals = ergoterm.filter_by_tag("dev")
<

ergoterm.get_focused()                             *ergoterm.get_focused()*
    Returns the terminal that currently has window focus.

    Returns: ~
        Terminal or `nil`

ergoterm.identify()                                   *ergoterm.identify()*
    Returns the terminal associated with the current buffer.

    Returns: ~
        Terminal or `nil`

ergoterm.get_target_for_bang()             *ergoterm.get_target_for_bang()*
    Returns the most recently focused terminal eligible for bang commands.

    If universal_selection is enabled, returns the last focused terminal
    regardless of its `bang_target` flag. Otherwise, returns the last focused
    terminal that has `bang_target = true`.

    Returns: ~
        Terminal or `nil`

ergoterm.select({defaults})                           *ergoterm.select()*
    Presents a picker interface for terminal selection.

    Parameters: ~
        {defaults}  (table, optional) Configuration options:
                    - terminals: Terminals to choose from (default: auto-list
                      terminals that are active or sticky)
                    - prompt: Picker prompt text (default: "Please select a
                      terminal")
                    - callbacks: Action callbacks (see below)
                    - picker: Custom picker implementation

    Callbacks can be provided in two formats:

    1. Simple function: A single function for the default action >lua
        callbacks = function(term) term:toggle() end
<
    2. Table of keybindings: A table mapping keys to action definitions >lua
        callbacks = {
          default = {
            fn = function(term) term:toggle() end,
            desc = "Toggle terminal"
          },
          ["<C-x>"] = {
            fn = function(term) term:close() end,
            desc = "Close terminal"
          }
        }
<
    Each action must have:
    - fn: Function that receives the terminal as parameter
    - desc: Description shown in the picker

    Returns: ~
        Result from picker, or `nil` if no terminals available

    Example: >lua
        local dev_terms = ergoterm.filter_by_tag("dev")

        ergoterm.select({
          terminals = dev_terms,
          prompt = "Select Development Terminal",
          callbacks = function(term)
            term:toggle()
          end
        })
<

ergoterm.select_started({defaults})           *ergoterm.select_started()*
    Presents a picker interface for started terminals only.

    Filters the provided terminals to only include those that have been
    started. If none are started and a `default` terminal is provided, that
    terminal is selected instead.

    Parameters: ~
        {defaults}  (table) Configuration options (same as |ergoterm.select()|)
                    Additional field:
                    - default: Terminal to select when none are started

    Behavior:
    - If no terminals are started and `default` is provided: selects default
    - If one terminal is started: selects it directly (no picker shown)
    - If multiple terminals are started: shows picker

    Returns: ~
        Result from picker, or `nil` if no started terminals available

    Example: >lua
        local chats = ergoterm.filter_by_tag("ai_chat")

        ergoterm.select_started({
          terminals = chats,
          prompt = "Send to chat",
          callbacks = function(term)
            term:send("single_line")
          end,
          default = claude_sonnet
        })
<

ergoterm.cleanup_all({opts})                       *ergoterm.cleanup_all()*
    Cleans up all terminals in the current session. This is a destructive
    operation that cannot be undone.

    Parameters: ~
        {opts}  (table, optional) Cleanup options:
                - force: Force removal of sticky terminals (boolean,
                  default: false)

    Example: >lua
        ergoterm.cleanup_all({ force = true })
<

ergoterm.toggle_universal_selection()  *ergoterm.toggle_universal_selection()*
    Toggles universal selection mode.

    When enabled, all terminals are shown in the default selection and can be
    targeted by bang commands, regardless of their `auto_list` or
    `bang_target` settings.

    Returns: ~
        boolean - The new state after toggling

ergoterm.get_state({key})                             *ergoterm.get_state()*
    Accesses internal module state. Primarily used for debugging and testing.

    Parameters: ~
        {key}  (string) State key to retrieve

    Returns: ~
        State value for the given key

ergoterm.reset_ids()                                 *ergoterm.reset_ids()*
    Resets the terminal ID sequence back to 1.

    Terminal IDs are never reused, even after deletion. This function clears
    the ID history, allowing the sequence to restart from 1. Useful for
    testing.

------------------------------------------------------------------------------
6.2 INSTANCE METHODS                                    *ergoterm-instance*

Instance methods are called on individual terminal objects.

term:start()                                                *term:start()*
    Initializes the terminal job and buffer.

    Recomputes the working directory, starts the job with configured
    environment and handlers, sets up buffer autocommands, and triggers the
    `on_start` callback.

    Returns: ~
        Terminal (self)

term:is_started()                                      *term:is_started()*
    Checks if the terminal job is running.

    Returns: ~
        boolean

term:stop()                                                  *term:stop()*
    Terminates the terminal job.

    Stops the underlying job process, closes any open windows, and triggers
    the `on_stop` callback.

    Returns: ~
        Terminal (self)

term:is_active()                                        *term:is_active()*
    Checks if the terminal has an active buffer.

    A terminal is active when started or when already stopped but not yet
    cleaned up.

    Returns: ~
        boolean

term:cleanup({opts})                                      *term:cleanup()*
    Cleans up the terminal.

    Stops the terminal if needed and removes the buffer reference. If the
    terminal is not sticky or `opts.force` is true, it will be removed from
    the collection entirely.

    Parameters: ~
        {opts}  (table, optional) Cleanup options:
                - force: Force removal even if sticky (boolean, default: false)

term:is_cleaned_up()                                *term:is_cleaned_up()*
    Checks if the terminal has been cleaned up.

    A terminal is cleaned up when it has been started at least once and its
    buffer is no longer present.

    Returns: ~
        boolean

term:open({layout})                                          *term:open()*
    Creates a window for the terminal without focusing it.

    Automatically starts the terminal if not already started. Uses the
    provided layout or falls back to the terminal's configured layout.

    Parameters: ~
        {layout}  (string, optional) Window layout: "below", "above", "left",
                  "right", "float", "tab", "window"

    Returns: ~
        Terminal (self)

term:is_open()                                            *term:is_open()*
    Returns whether the terminal window is currently open.

    Returns: ~
        boolean

term:close()                                                *term:close()*
    Closes the terminal window while keeping the job running.

    If the terminal is the only window open, it replaces its buffer with an
    empty buffer to avoid closing Vim entirely. Persists the window size if
    `persist_size` is enabled. Triggers the `on_close` callback.

    Returns: ~
        Terminal (self)

term:focus({layout})                                        *term:focus()*
    Brings the terminal window into focus and switches to it.

    Automatically starts and opens the terminal if needed. Switches to the
    terminal's tabpage and window. Sets the terminal as the last focused
    terminal and sets up the appropriate terminal mode. Triggers the
    `on_focus` callback.

    Parameters: ~
        {layout}  (string, optional) Window layout to use if opening for the
                  first time

    Returns: ~
        Terminal (self)

term:is_focused()                                      *term:is_focused()*
    Checks if this terminal is the currently active window.

    Returns: ~
        boolean

term:unfocus({win_id})                                    *term:unfocus()*
    Removes focus from the terminal window.

    Persists mode if configured and closes floating terminals. Optionally
    switches to a different window. Triggers the `on_unfocus` callback.

    Parameters: ~
        {win_id}  (number, optional) Window ID to switch to after unfocusing

    Returns: ~
        Terminal (self)

term:toggle({layout})                                      *term:toggle()*
    Toggles terminal state between focused and closed.

    Closes the terminal if currently open, or focuses it if closed.

    Parameters: ~
        {layout}  (string, optional) Window layout to use when opening

    Returns: ~
        Terminal (self)

    Example: >lua
        vim.keymap.set("n", "<leader>tt", function()
          term:toggle()
        end)
<

term:send({input}, {opts})                                  *term:send()*
    Sends text input to the terminal job.

    Parameters: ~
        {input}  (string[]|string) Text to send (array of lines) or selection
                 type:
                 - "single_line": Sends the current line
                 - "visual_lines": Sends lines covered by visual line selection
                 - "visual_selection": Sends exact text covered by visual
                   selection
                 - "last": Resends the last sent text

        {opts}  (table, optional) Send options:
                - action: Terminal action ("focus", "open", "start")
                - trim: Trim whitespace (boolean, default: true)
                - new_line: Append newline to execute command (boolean,
                  default: true)
                - clear: Clear terminal before sending (boolean, default: false)
                - decorator: Text decorator to apply (string|function)

    Returns: ~
        Terminal (self)

    Example: >lua
        term:send({ "echo 'hello'" })
        term:send("single_line", { action = "open", new_line = false })
        term:send("last")
<

term:clear({action})                                        *term:clear()*
    Clears the terminal display.

    Sends the appropriate clear command for the current platform (`cls` on
    Windows, `clear` on Unix systems).

    Parameters: ~
        {action}  (string, optional) Terminal action before clearing: "focus",
                  "open", "start"

term:update({settings}, {opts})                            *term:update()*
    Updates terminal settings after creation.

    Parameters: ~
        {settings}  (table) Properties to update. See
                    |ergoterm-terminal-defaults| for available options.
        {opts}  (table, optional) Update options:
                - deep_merge: Deep merge table settings (boolean,
                  default: false)

    Note: Cannot update immutable properties: `cmd`, `dir`, `scrollback`, `env`

    Returns: ~
        Terminal or `nil`

    Example: >lua
        term:update({ layout = "float", size = { below = "40%" } })
<

term:get_status_icon()                            *term:get_status_icon()*
    Gets the status icon for the terminal.

    Returns an appropriate UTF icon based on the current terminal state:
    - ○ Not active (only for sticky terminals)
    - ▶ Started and running
    - ✓ Stopped but active, process succeeded
    - ✗ Stopped but active, process failed

    Returns: ~
        string

term:get_state({key})                                  *term:get_state()*
    Accesses internal terminal state. Primarily used for debugging and
    testing.

    Parameters: ~
        {key}  (string) State key to retrieve

    Returns: ~
        State value for the given key


==============================================================================
7. ABOUT                                                      *ergoterm-about*

ACKNOWLEDGMENTS ~

This plugin started as a fork of toggleterm.nvim
(https://github.com/akinsho/toggleterm.nvim). Thanks to the original author
and contributors for their foundational work.

LICENSE ~

GPL-3.0

CONTRIBUTING ~

Contributions are welcome! Visit the GitHub repository:
https://github.com/waiting-for-dev/ergoterm.nvim

vim:tw=78:ts=8:ft=help:norl:
